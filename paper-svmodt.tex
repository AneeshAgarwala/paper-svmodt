% !TeX root = RJwrapper.tex
\title{svmodt: An R Package for Linear SVM-Based Oblique Decision Trees}


\author{by Aneesh Agarwal, Jack Jewson, and Erik Sverdrup}

\maketitle

\abstract{%
An abstract of less than 150 words.
}

\section{Introduction}\label{introduction}

\section{Background}\label{background}

\subsection{Decision Trees}\label{decision-trees}

Decision Trees (DTs) are interpretable classification models that represent their decision-making process through a hierarchical, tree-like structure. This structure comprises internal nodes containing splitting criteria and terminal (leaf) nodes corresponding to class labels. The nodes are connected by directed edges, each representing a possible outcome of a splitting criterion. Formally, a DT can be expressed as a rooted, directed tree \(T = (G(V, E), v_1)\), where \(V\) denotes the set of nodes, \(E\) represents the set of edges linking these nodes, and \(v_1\) is the root node.

If the tree \(T\) has \(m\) nodes, then for any \(j \in \{1, \ldots, m\}\), the set of child nodes of \(v_j \in V\) can be defined as:

\[
N^{+}(v_j) = \{ v_k \in V \mid k \in \{1, \ldots, m\},\; k \neq j,\; (v_j, v_k) \in E \}.
\]

Here, \(N^{+}(v_j)\) denotes the set of nodes that are directly connected to \(v_j\) through outgoing edges, representing all possible child nodes that can be reached from \(v_j\) within the tree structure \citep{lopez2018}.

Decision tree algorithms can be categorized based on whether the same type of test is applied at all internal nodes. \textbf{Homogeneous trees} employ a single algorithm throughout (e.g., univariate or multivariate splits), whereas \textbf{hybrid trees} allow different algorithms such as linear discriminant functions, \(k\)-nearest neighbors, or univariate splits that can be used in different subtrees \citep{brodley1995}. Hybrid trees exploit the principle of \emph{selective superiority}, allowing subsets of the data to be modeled by the most appropriate classifier, thereby improving flexibility and accuracy.

\subsubsection{Univariate Decision Trees}\label{univariate-decision-trees}

Univariate Decision Trees (UDTs) trees represent axis-parallel hyperplanes dividing the instance space into several disjoint regions. Axis-parallel decision trees, such as CART and C4.5, represent two of the most widely used algorithms for classification tasks. The \textbf{CART (Classification and Regression Trees)} algorithm employs a binary recursive partitioning procedure capable of handling both continuous and categorical variables as predictors or targets. It operates directly on raw data without requiring binning. The tree is expanded recursively until no further splits are possible, after which \textbf{cost-complexity pruning} is applied to remove branches that contribute least to predictive performance. This pruning process generates a sequence of nested subtrees, from which the optimal model is selected using independent test data or cross-validation, rather than internal training measures \citep{breiman1984}.

In contrast, \textbf{C4.5}, an extension of the earlier \textbf{ID3} algorithm \citep{quinlan1986}, utilizing information theory measures such as \textbf{information gain} and \textbf{gain ratio} to select the most informative attribute for each split \citep{quinlan1993}. C4.5 also includes mechanisms to handle missing attribute values by weighting instances according to the proportion of known data and employs an \textbf{error-based pruning} method to reduce overfitting. Although these techniques are effective across diverse datasets, studies have shown that the choice of pruning strategy and stopping criteria can significantly affect model performance across different domains \citep{mingers1989, schaffer1992}.

While UDTs are highly interpretability, they are characterised by several representational limitations. Such trees often grow unnecessarily large, as they must approximate complex relationship between features through multiple axis-aligned partitions. This can result in the replication of subtrees and repeated testing of the same feature along different paths, both of which reduce efficiency and hinder generalization performance \citep{pagallo1990}.

\subsubsection{Multivariate Decision Trees}\label{multivariate-decision-trees}

Multivariate decision trees (MDTs) extends UDTs by allowing each internal node to perform splits based on linear or nonlinear combinations of multiple features. This flexibility enables the tree to form oblique decision boundaries that more accurately partition the instance space. For example, a single multivariate test such as \(x + y < 8\) can replace multiple univariate splits needed to approximate the same boundary. The construction of MDTs introduces several design considerations, including how to represent multivariate tests, determine their coefficients, select features to include, handle symbolic and missing data, and prune to avoid overfitting \citep{brodley1995}.

Various optimization algorithms---such as recursive least squares \citep{young1984}, the pocket algorithm \citep{gallant1986}, or thermal training \citep{frean1990}---may be used to estimate the weights. However, MDTs trade interpretability for representational power and often require additional mechanisms for \textbf{local feature selection}, such as \emph{sequential forward selection} (SFS) or \emph{sequential backward elimination} (SBE) \citep{kittler1986}.

Empirical comparisons across multiple datasets demonstrate that multivariate trees generally achieve higher accuracy and smaller tree sizes than their univariate counterparts, though this comes at the cost of reduced interpretability. Moreover, MDTs retain key advantages of standard decision trees---such as sequential split criteria evaluation and transparent decision procedures---while offering improved modeling flexibility for complex datasets \citep{kozial2009, friedl1997, huan1998, canete}.

\subsection{Support Vector Machines (SVMs)}\label{support-vector-machines-svms}

Support Vector Machines (SVMs) are powerful supervised learning models used for classification and regression tasks. They aim to determine an optimal separating hyperplane that maximizes the margin between different classes in the data. This margin-based approach enhances the generalization ability of the model, making SVMs robust and effective for many real-world problems \citep{cristianini2000}.

\subsubsection{Linear SVMs}\label{linear-svms}

A simplest \textbf{linear SVMs} construct a separating hyperplane in an \(n\)-dimensional space such that the margin between the classes is maximized. Given a training dataset \(\{(\mathbf{x}_i, y_i)\}_{i=1}^{N}\), where \(\mathbf{x}_i \in \mathbb{R}^n\) and \(y_i \in \{-1, +1\}\), the decision function is defined as:

\[
f(\mathbf{x}) = \text{sign}(\mathbf{w}^\top \mathbf{x} + b),
\]

where \(\mathbf{w}\) is the weight vector perpendicular to the hyperplane, and \(b\) is the bias term. The optimal hyperplane is the one that maximizes the distance between the closest points of each class (the \textbf{support vectors}) and the hyperplane itself \citep{cortes1995}.

Mathematically, the optimization problem for a hard-margin SVM (i.e., assuming the data are linearly separable) can be formulated as:

\[
\min_{\mathbf{w}, b} \ \frac{1}{2} \|\mathbf{w}\|^2
\] subject to: \[
y_i (\mathbf{w}^\top \mathbf{x}_i + b) \geq 1, \quad i = 1, 2, \ldots, N.
\]

Here, \(\|\mathbf{w}\|\) represents the norm of the weight vector and acts as a regularization term that controls the complexity of the model. The constraint ensures that all data points are correctly classified and lie outside the margin boundaries.

However, in most practical situations, perfect linear separability is not achievable. To address this, \textbf{soft-margin SVMs} introduce slack variables \(\xi_i \geq 0\) to allow certain violations of the margin constraints, resulting in the following optimization problem:

\[
\min_{\mathbf{w}, b, \xi} \ \frac{1}{2} \|\mathbf{w}\|^2 + C \sum_{i=1}^{N} \xi_i
\] subject to: \[
y_i (\mathbf{w}^\top \mathbf{x}_i + b) \geq 1 - \xi_i, \quad \xi_i \geq 0, \quad i = 1, 2, \ldots, N.
\]

The parameter \(C > 0\) controls the trade-off between maximizing the margin and minimizing the classification error on the training data. A large \(C\) penalizes mis-classifications heavily, leading to a narrower margin, whereas a smaller \(C\) allows more flexibility, potentially improving generalization in the presence of noise.

The solution to this constrained optimization problem is obtained using \textbf{Lagrange multipliers}, resulting in a dual formulation expressed as:

\[
\max_{\alpha} \sum_{i=1}^{N} \alpha_i - \frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N} \alpha_i \alpha_j y_i y_j \langle \mathbf{x}_i, \mathbf{x}_j \rangle
\] subject to: \[
\sum_{i=1}^{N} \alpha_i y_i = 0, \quad 0 \leq \alpha_i \leq C.
\]

The data points corresponding to non-zero \(\alpha_i\) values are the \textbf{support vectors}, which define the decision boundary. The resulting decision function for a new observation \(\mathbf{x}\) is given by:

\[
f(\mathbf{x}) = \text{sign}\left(\sum_{i=1}^{N} \alpha_i y_i \langle \mathbf{x}_i, \mathbf{x} \rangle + b\right).
\]

This formulation highlights one of the most important properties of SVMs --- the decision boundary depends only on a subset of the training data (the support vectors), making SVMs both efficient and robust in representing the learned model \citep{cervantes2020}.

\subsubsection{Non-Linear SVMs}\label{non-linear-svms}

While linear classifiers provide useful insights, they are often inadequate for real-world datasets, where classes are not linearly separable. In such cases, SVMs can be extended to create \textbf{nonlinear decision boundaries} by mapping the input vectors into a higher-dimensional \textbf{feature space} using a nonlinear transformation \(\phi: \mathbb{R}^n \rightarrow \mathcal{F}\). The linear transformation is then achieved in the transformed space using:

\[
f(\mathbf{x}) = \text{sign}(\mathbf{w}^\top \phi(\mathbf{x}) + b).
\]

However, directly computing \(\phi(\mathbf{x})\) can be computationally expensive. To address this, SVMs employ the \textbf{kernel trick}, where the dot product in the feature space is replaced with a kernel function \(K(\mathbf{x}_i, \mathbf{x}_j)\):

\[
K(\mathbf{x}_i, \mathbf{x}_j) = \langle \phi(\mathbf{x}_i), \phi(\mathbf{x}_j) \rangle.
\]

The resulting decision function becomes:

\[
f(\mathbf{x}) = \text{sign}\left(\sum_{i=1}^{N} \alpha_i y_i K(\mathbf{x}_i, \mathbf{x}) + b\right),
\]

where \(\alpha_i\) are the Lagrange multipliers obtained during training.

For a function \(K\) to be a valid kernel, it must satisfy \textbf{Mercer's condition} \citep{vapnik2013} i.e., the kernel matrix must be symmetric and positive semi-definite. Table \ref{tab:kernels-tab-static}

\begin{table}
\centering
\caption{\label{tab:kernels-tab-static}Commonly used kernel functions and their parameters.}
\centering
\fontsize{7}{9}\selectfont
\begin{tabular}[t]{l|l|l}
\hline
Kernel Type & Mathematical Definition & Key Parameters\\
\hline
Linear & $K(\mathbf{x}_i, \mathbf{x}_j) = \mathbf{x}_i^\top \mathbf{x}_j$ & None\\
\hline
Polynomial & $K(\mathbf{x}_i, \mathbf{x}_j) = (\mathbf{x}_i^\top \mathbf{x}_j + 1)^d$ & Degree $d$\\
\hline
Gaussian & $K(\mathbf{x}_i, \mathbf{x}_j) = \exp\left(-\frac{\|\mathbf{x}_i - \mathbf{x}_j\|^2}{2\sigma^2}\right)$ & Bandwidth $\sigma$\\
\hline
RBF & $K(\mathbf{x}_i, \mathbf{x}_j) = \exp(-\gamma \|\mathbf{x}_i - \mathbf{x}_j\|^2)$ & $\gamma$\\
\hline
Sigmoid & $K(\mathbf{x}_i, \mathbf{x}_j) = \tanh(\kappa \mathbf{x}_i^\top \mathbf{x}_j + \theta)$ & $\kappa, \theta$\\
\hline
\end{tabular}
\end{table}

Although SVMs exhibit strong theoretical foundations and robust generalization capabilities, they present several practical limitations. Model performance is highly dependent on the appropriate selection of hyperparameters such as the regularization term (\(C\)) and kernel parameters (e.g., \(\gamma\)), which govern the trade-off between margin maximization and misclassification tolerance \citep{nanda2018}. Training an SVM requires solving a quadratic programming (QP) optimization problem involving an \(n \times n\) kernel matrix, where \(n\) denotes the number of training samples, leading to quadratic growth in both computational time and memory usage \citep{dong2005}. This makes SVMs computationally expensive for large-scale datasets. Moreover, SVMs are inherently designed for binary classification, necessitating decomposition strategies such as One-vs-One and One-vs-All for multi-class problems \citep{hsu2002}. Their performance also tends to degrade in imbalanced data settings, where the decision boundary becomes biased toward the majority class \citep{cervantes2020}.

\subsection{Hybrid Decision Trees with Support Vector Machines}\label{hybrid-decision-trees-with-support-vector-machines}

The earliest formalization of Support Vector Machine--based Decision Trees (DTSVMs) was introduced by \citet{bennet1998} , who extended the principles of Statistical Learning Theory \citep{vapnik2013} and Structural Risk Minimization (SRM) to the construction of binary decision trees. Each node of a decision tree was treated as an SVM that partitions data along an optimal hyperplane. This approach allowed for multivariate SVM decisions at each node. \citet{takahashi2002} extended DTSVMs to multiclass problems, using a recursive tree-based partitioning where the root separates the most separable class (or classes) from the rest. Subsequent nodes repeat this process until each leaf contains a single class, ensuring that all regions of the feature space are classified.

Subsequent studies have built upon this foundation to address scalability, optimization, and generalization issues. Optimal Decision Tree SVM (ODT-SVM) \citep{bala2011} introduced split-selection criteria based on Gini index, information gain, and scatter matrix separability to balance tree interpretability and margin-based precision.

\subsubsection{Oblique and Rotation-Based Extensions}\label{oblique-and-rotation-based-extensions}

Recent research has explored oblique and rotation-based decision ensembles that generalize the DTSVM concept. Oblique Double Random Forests with MPSVM (MPDRaF) \citep{ganaie2022} introduce multivariate (oblique) splits at each node using Multi-Plane SVM (MPSVM) formulations \citep{Mangasarian2006}, enhancing the geometric flexibility of decision boundaries. Regularization variants---such as Tikhonov, axis-parallel, and null-space---address sample-size limitations at deeper nodes, ensuring better generalization.

Similarly, Rotation-based Double Random Forests (DRaF) \citep{ganaie2022} employ Principal Component Analysis (PCA) and Linear Discriminant Analysis (LDA) transformations at non-terminal nodes to create diverse subspaces, improving ensemble diversity and classification stability.

\subsubsection{Modern Multi-class Integration}\label{modern-multi-class-integration}

Recent works such as the Oblique Decision Tree Ensemble (ODTE) \citep{montanana2025} embed multiple SVM classifiers (e.g., one-vs-one or one-vs-rest) directly at each split, dynamically selecting the model that minimizes class impurity. This enables efficient n-ary classification within a single tree structure, mitigating the scalability and imbalance limitations of traditional binary SVM extensions.

\subsection{Related Software Packages}\label{related-software-packages}

Several software packages provide functionality related to SVM-based decision trees, but fully-featured implementations of SVM Oblique Decision Trees (SVMODT) remain limited, particularly in R. In R, very scarce SVMODT implementation is available. The \CRANpkg{PPforest} package implements projection pursuit random forests, where trees are constructed by splitting on linear combinations of variables to maximize class separation, supporting multi-class problems and variable importance measures. In Python, \textbf{STree} \citep{Montanana2021} provides an oblique decision tree classifier based on SVM nodes, where each node is built and split using scikit-learn's \textbf{SVC} models \citep{scikit2011}. Java-based frameworks such as \textbf{Weka} provide classical decision trees (\textbf{J48}) and SVMs (\textbf{SMO}) that can be adapted for hierarchical SVM trees \citep{menkovski2008}. Overall, while multiple languages provide the building blocks---SVM training, decision tree construction, and ensemble methods---there is currently no widely available, fully integrated SVMODT software in R, highlighting the need for custom implementations or adaptation of existing tools for research and applied purposes.

\section{Methodology}\label{methodology}

To better understand the structure and mechanics of decision trees, we first implemented a standard axis-parallel decision tree in R from scratch before extending it into the oblique (SVM-based) variant.

\subsection{Custom Univariate Decision Tree with Integrated Cost-Complexity Pruning}\label{custom-univariate-decision-tree-with-integrated-cost-complexity-pruning}

This implementation presents a decision tree algorithm with \textbf{integrated cost-complexity pruning}, where pruning decisions are made during tree construction rather than as a post-processing step. The algorithm supports multiple splitting criteria and performs real-time pruning based on cost-complexity analysis.

\subsubsection{Algorithm Description}\label{algorithm-description}

At each node \(v\) with samples \(\mathcal{D}_v\) and labels \(\mathcal{Y}_v\), the algorithm:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Compute Node Statistics}: At each node of the decision tree, several key statistics are computed to guide the splitting process. The class probabilities are calculated as \(p_c = \frac{n_c}{n},\) where \(n_c\) is the count of samples belonging to class \(c\) in the node, and \(n = |D_v|\) is the total number of samples at the node. The predicted class is assigned as the class with the highest probability, \[\hat{y} = \arg\max_c p_c.\]
\item
  \textbf{Select Optimal Split}: The optimal split at each node is determined using one of three criteria:

  \begin{itemize}
  \item
    \textbf{Gini Impurity} is defined as \[\text{Gini}(\mathcal{Y}) = 1 - \sum_{c=1}^{K} p_c^2,\]where \(p_c\) is the proportion of samples belonging to class \(c\) in node \(\mathcal{Y}\) \citep{breiman1984}.
  \item
    \textbf{Information Gain} evaluates the reduction in node impurity and is computed as \[\text{IG}(f, s) = H(\mathcal{Y}_v) - \sum_{i \in \{L, R\}} \frac{n_i}{n} H(\mathcal{Y}_i),\]where \(H(\mathcal{Y})\) denotes the impurity of a node (entropy or Gini), \(n_i\) is the number of samples in the child node, and \(n\) is the number of samples in the parent node {[}\citet{breiman1984}{[}.
  \item
    \textbf{Gain Ratio} further adjusts Information Gain by penalizing splits that create many small partitions \citep{quinlan1993} and is defined as \[\text{GR}(f, s) = \frac{\text{IG}(f, s)}{\text{SI}(f, s)},\]where the split information is \[\text{SI}(f, s) = -\sum_{i \in \{L, R\}} \frac{n_i}{n} \log_2\left(\frac{n_i}{n}\right).\]
  \end{itemize}
\item
  \textbf{Evaluates Pruning Criteria}: To ensure the tree remains interpret-able and avoids over-fitting, integrated pruning is performed using cost-complexity analysis. The cost of a sub-tree \(T_v\) is given by \[R_\alpha(T_v) = R(T_v) + \alpha \|T_v\|,\] where \(R(T_v)\) is the miss-classification error, \(|T_v|\) is the number of leaves in the sub-tree, and \(\alpha \geq 0\) is a complexity parameter controlling the trade-off between accuracy and simplicity. For a single leaf node \(t_v\), the cost is \[R_\alpha(t_v) = R(t_v) + \alpha.\] A sub-tree \(T_v\) is pruned, i.e., replaced by a single leaf node, if \[R_\alpha(t_v) \leq R_\alpha(T_v),\]ensuring that further splits are retained only when they yield sufficient reduction in classification error to justify the added complexity.
\end{enumerate}

\begin{algorithm}
\caption{Decision Tree with Integrated Cost-Complexity Pruning}
\label{alg:custom-tree}
\begin{algorithmic}[1]
\STATE \textbf{Procedure} GenerateTree($\mathcal{Y}, \mathbf{X}, d, d_{\max}, \alpha$)
    \STATE $n \gets |\mathcal{Y}|$
    \STATE $\mathbf{p} \gets \text{ClassProbabilities}(\mathcal{Y})$
    \STATE $\hat{y} \gets \arg\max_c p_c$
    
    \IF{$d \geq d_{\max}$ \textbf{or} $|\text{unique}(\mathcal{Y})| \leq 1$}
        \RETURN $\text{LeafNode}(\hat{y}, \mathbf{p}, n)$
    \ENDIF
    
    \STATE $(f^*, s^*, \text{score}) \gets \text{FeatureSelector}(\mathcal{Y}, \mathbf{X}, \text{criterion})$
    
    \IF{$f^* = \text{null}$ \textbf{or} $\text{score} = -\infty$}
        \RETURN $\text{LeafNode}(\hat{y}, \mathbf{p}, n)$
    \ENDIF
    
    \STATE $\mathcal{I}_L, \mathcal{I}_R \gets \text{Split}(\mathbf{X}[f^*], s^*)$
    
    \IF{$|\mathcal{I}_L| = 0$ \textbf{or} $|\mathcal{I}_R| = 0$}
        \RETURN $\text{LeafNode}(\hat{y}, \mathbf{p}, n)$
    \ENDIF
    
    \STATE $T_L \gets \textsc{GenerateTree}(\mathcal{Y}[\mathcal{I}_L], \mathbf{X}[\mathcal{I}_L], d+1, d_{\max}, \alpha)$
    \STATE $T_R \gets \textsc{GenerateTree}(\mathcal{Y}[\mathcal{I}_R], \mathbf{X}[\mathcal{I}_R], d+1, d_{\max}, \alpha)$
    
    \STATE $T_v \gets \text{InternalNode}(f^*, s^*, T_L, T_R, \hat{y}, \mathbf{p}, n)$
    
    \STATE \COMMENT{Integrated pruning decision}
    \STATE $R_{\text{subtree}} \gets \text{SubtreeError}(T_v) + \alpha \cdot \text{CountLeaves}(T_v)$
    \STATE $R_{\text{leaf}} \gets (1 - \max(\mathbf{p})) + \alpha$
    
    \IF{$R_{\text{leaf}} \leq R_{\text{subtree}}$}
        \RETURN $\text{LeafNode}(\hat{y}, \mathbf{p}, n)$ \COMMENT{Prune subtree}
    \ELSE
        \RETURN $T_v$
    \ENDIF
\STATE \textbf{End Procedure}
\end{algorithmic}
\end{algorithm}

The custom uni variate decision tree implementation in R combines axis-parallel splits with integrated cost-complexity pruning, offering several key differences from standard CART/\CRANpkg{rpart} trees. Numeric features are split only at midpoints where class labels change, while categorical features use binary splits at each level, reducing computational complexity. Splitting criteria include Gini impurity, information gain, and Gain Ratio---the latter penalizing splits with high split information to favor balanced partitions. Integrated pruning is applied during tree construction using a fixed \(\alpha\) parameter, replacing sub-trees with leaves whenever the cost-complexity criterion is satisfied, unlike CART/\CRANpkg{rpart}, which performs post-pruning via cross-validation. This single-pass pruning approach reduces training time and space requirements, while still producing interpret-able trees. Predictions follow standard tree traversal, returning majority-class labels or probability estimates at leaves.

\subsection{Support Vector Machine based Oblique Decision Trees}\label{support-vector-machine-based-oblique-decision-trees}

\subsubsection{Algorithm Description}\label{algorithm-description-1}

The SVM Oblique Decision Tree (SVMODT) constructs a binary classification decision tree where each internal node \(v\) at depth \(d\). The algorithm is implemented in R using the \CRANpkg{e1071} performs the following operations:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Feature Selection:} A subset of \(m_d\) features is dynamically selected from the available feature set \(\mathcal{F}\). This selection can be done using one of several strategies, including random selection, sampling, mutual information ranking (using the \CRANpkg{FSelectorRcpp} package), or correlation-based selection. This allows the tree to adaptive-ly focus on the most informative features at each node.
\item
  \textbf{Feature Scaling:} Once the features are selected, z-score normalization is applied to standardize them. For the selected feature matrix \(\mathbf{X}_v \in \mathbb{R}^{n \times m_d}\), the scaled features are computed as \[\mathbf{X}_v^{\text{scaled}} = \frac{\mathbf{X}_v - \boldsymbol{\mu}_v}{\boldsymbol{\sigma}_v},\] where \(\boldsymbol{\mu}_v\) and \(\boldsymbol{\sigma}_v\) denote the mean and standard deviation of the features in node \(v\).
\item
  \textbf{SVM Training:} A linear SVM is then trained on the scaled features. Optional class weights \(w_c\) can be applied to handle imbalanced data. The SVM optimization problem is formulated as \[\min_{\mathbf{w}, b} \frac{1}{2}\|\mathbf{w}\|^2 + C \sum_{i=1}^{n} w_{y_i} \xi_i,\] where \(C\) is the regularization parameter, \(\xi_i\) are slack variables, and \(w_{y_i}\) represents the class-specific weight for sample \(i\).
\item
  \textbf{Node Splitting:} After training, the decision values for each sample are computed as \(f(x_i) = \mathbf{w}^T x_i + b.\) Samples are then partitioned into left and right child nodes according to the sign of \(f(x_i)\):

  \begin{itemize}
  \item
    Left child: \(\{i : f(x_i) > 0\}\)
  \item
    Right child: \(\{i : f(x_i) \leq 0\}\)
  \end{itemize}
\end{enumerate}

This process recursively continues for each child node until stopping criteria are met.

\begin{algorithm}
\caption{SVM Oblique Decision Tree Construction}
\label{alg:svmodt}
\begin{algorithmic}[1]
\STATE \textbf{Procedure} SVMSplit($\mathcal{D}, d, d_{\max}, n_{\min}$)
    \STATE $n \gets |\mathcal{D}|$, $\mathcal{Y} \gets \text{labels}(\mathcal{D})$
    
    \IF{$d > d_{\max}$ \textbf{or} $|\text{unique}(\mathcal{Y})| = 1$ \textbf{or} $n < n_{\min}$}
        \RETURN $\text{LeafNode}(\mathcal{Y})$ \COMMENT{Stopping criteria}
    \ENDIF
    
    \STATE $m_d \gets \text{DynamicMaxFeatures}(d, m_{\text{base}}, \text{strategy})$
    \STATE $\mathcal{F}_d \gets \text{SelectFeatures}(\mathcal{D}, m_d, \text{method})$
    \STATE $\mathbf{X}_{\text{scaled}}, \text{scaler} \gets \text{Scale}(\mathcal{D}[\mathcal{F}_d])$
    
    \IF{$|\mathcal{F}_d| = 0$}
        \RETURN $\text{LeafNode}(\mathcal{Y})$ \COMMENT{No valid features}
    \ENDIF
    
    \STATE $w_c \gets \text{CalculateClassWeights}(\mathcal{Y}, \text{strategy})$
    \STATE $\text{SVM} \gets \text{FitLinearSVM}(\mathbf{X}_{\text{scaled}}, \mathcal{Y}, w_c)$
    
    \IF{$\text{SVM} = \text{null}$}
        \RETURN $\text{LeafNode}(\mathcal{Y})$ \COMMENT{SVM fitting failed}
    \ENDIF
    
    \STATE $\mathbf{f} \gets \text{SVM.DecisionValues}(\mathbf{X}_{\text{scaled}})$
    \STATE $\mathcal{I}_L \gets \{i : f_i > 0\}$, $\mathcal{I}_R \gets \{i : f_i \leq 0\}$
    
    \IF{$|\mathcal{I}_L| = 0$ \textbf{or} $|\mathcal{I}_R| = 0$}
        \RETURN $\text{LeafNode}(\mathcal{Y})$ \COMMENT{Ineffective split}
    \ENDIF
    
    \STATE $\text{left} \gets \textsc{SVMSplit}(\mathcal{D}[\mathcal{I}_L], d+1, d_{\max}, n_{\min})$
    \STATE $\text{right} \gets \textsc{SVMSplit}(\mathcal{D}[\mathcal{I}_R], d+1, d_{\max}, n_{\min})$
    
    \RETURN $\text{InternalNode}(\text{SVM}, \mathcal{F}_d, \text{scaler}, \text{left}, \text{right})$
\STATE \textbf{End Procedure}
\end{algorithmic}
\end{algorithm}

\subsubsection{Key Hyper-parameters}\label{key-hyper-parameters}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Feature Selection:} The algorithm supports three strategies for selecting features at each node. The maximum number of features considered at depth \(d\) is defined as:
\end{enumerate}

\[
m_d =
\begin{cases}
m_{\text{base}} & \text{constant strategy} \\
\lfloor m_{\text{base}} \cdot \alpha^{d-1} \rfloor & \text{decrease strategy} \\
\text{Uniform}(\lfloor p \cdot \ell_{\min} \rfloor, \lfloor p \cdot \ell_{\max} \rfloor) & \text{random strategy}
\end{cases}
\]

Here, \(\alpha \in (0, 1]\) is the decrease rate for the ``decrease strategy,'' \(p\) is the total number of features, \(\ell_{\min}\) and \(\ell_{\max}\) define the fractional bounds for the random strategy, and \(m_{\text{base}}\) is the base number of features at the first depth.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  \textbf{Feature Penalty:} To encourage diversity in feature usage across the tree, previously used features have their selection weight reduced by a factor of \((1 - \lambda)\), where \(\lambda \in [0, 1)\).
\item
  \textbf{Class Weight Handling:} To address class imbalance, the algorithm allows four weighting schemes:

  \begin{itemize}
  \item
    \textbf{None:} \(w_c = 1\) for all classes.
  \item
    \textbf{Balanced:} \(w_c = \frac{n}{K \cdot n_c}\), where \(K\) is the total number of classes and \(n_c\) is the number of samples in class \(c\).
  \item
    \textbf{Balanced sub-sample:} \(w_c = \frac{1}{n_c} \cdot \frac{K}{\sum_{c'} 1/n_{c'}}\), which adjusts weights for sub-sampled data.
  \item
    \textbf{Custom:} Users can define their own class weights.
  \end{itemize}
\end{enumerate}

\subsubsection{Interaction with SVM Training and Node Splitting}\label{interaction-with-svm-training-and-node-splitting}

The hyper-parameters described above directly influence the behavior of the SVM-based decision tree at each node. The feature selection strategy determines which subset of features \(\mathcal{F}_d\) is used to fit the linear SVM at depth \(d\), which affects the orientation and effectiveness of the decision hyper-plane. Feature penalties ensure that no single feature dominates multiple splits, promoting diversity in the learned splits and improving generalization. Once the SVM is trained on the selected and scaled features, the decision values are used to partition the samples into left and right child nodes. By controlling the number of features, penalizing repeated use, and adjusting class weights, the tree can achieve a balance between predictive accuracy, interpret-ability, and computational efficiency.

\section{Data}\label{data}

In this study, we evaluate the SVM-based oblique decision tree (SVMODT) on two widely used benchmark datasets: \textbf{Palmer Penguins} and \textbf{Wisconsin Diagnostic Breast Cancer (WDBC)}. These datasets provide a mix of multi-class and binary classification problems, as well as numeric and categorical features, making them suitable for testing the flexibility and interpretability of SVMODTs.

\subsection{Palmer Penguins}\label{palmer-penguins}

The \CRANpkg{palmerpenguins} data set is a multi-class data set containing morphological measurements for three penguin species (\emph{Adelie}, \emph{Chinstrap}, and \emph{Gentoo}) observed on the Palmer Archipelago, Antarctica. The data set includes 344 complete observations with the following features:

\begin{itemize}
\tightlist
\item
  \textbf{bill\_length\_mm}: Length of the bill (numeric)\\
\item
  \textbf{bill\_depth\_mm}: Depth of the bill (numeric)\\
\item
  \textbf{flipper\_length\_mm}: Length of the flipper (numeric)\\
\item
  \textbf{body\_mass\_g}: Body mass (numeric)\\
\item
  \textbf{sex}: Sex of the penguin (categorical)\\
\item
  \textbf{species}: Target class (categorical with three levels)
\end{itemize}

\subsection{Wisconsin Diagnostic Breast Cancer (WDBC)}\label{wisconsin-diagnostic-breast-cancer-wdbc}

The \textbf{WDBC} \citep{Street1993} data set is a binary classification data set derived from fine needle aspirates of breast tissue. It contains 569 observations with 30 numeric features computed from digitized images of cell nuclei. The features include measures such as \textbf{radius, texture, perimeter, area, smoothness, compactness, concavity, concave points, symmetry, fractal dimension} The target variable is \textbf{diagnosis} (Malignant (M) or benign (B) tumor). This data set is widely used for testing high-dimensional binary classification algorithms. Its numeric nature allows direct evaluation of SVM splits and the effect of class weighting strategies on imbalanced classes.

\subsection{Data Preparation}\label{data-preparation}

For both data sets, the following pre-processing steps are applied before training the SVMODT:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Missing Values}: Rows with missing values are removed.
\item
  \textbf{Class Filtering}: For Palmer Penguins, rows corresponding to the \emph{Gentoo} species are removed using \CRANpkg{dplyr} to create a binary classification problem.
\item
  \textbf{Categorical Encoding}: Categorical variables (e.g., \textbf{sex} in Palmer Penguins) are encoded as factor levels suitable for training.
\end{enumerate}

These pre-processing steps ensure that SVMODT can learn meaningful oblique splits across both data sets while maintaining interpret-ability.

\section{Code Examples}\label{code-examples}

\section{Results}\label{results}

\section{Discussion}\label{discussion}

\bibliography{RJreferences.bib}

\address{%
Aneesh Agarwal\\
Monash University\\%
\\
%
%
%
\href{mailto:aaga0022@student.monash.edu}{\nolinkurl{aaga0022@student.monash.edu}}%
}

\address{%
Jack Jewson\\
Monash University\\%
Department of Econometrics and Business Statistics, Monash University, Australia\\
%
%
%
\href{mailto:Jack.Jewson@monash.edu}{\nolinkurl{Jack.Jewson@monash.edu}}%
}

\address{%
Erik Sverdrup\\
Monash University\\%
Department of Econometrics and Business Statistics, Monash University, Australia\\
%
%
%
\href{mailto:Erik.Sverdrup@monash.edu}{\nolinkurl{Erik.Sverdrup@monash.edu}}%
}
